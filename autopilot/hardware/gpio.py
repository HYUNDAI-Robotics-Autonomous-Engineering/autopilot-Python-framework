"""
Hardware that uses the GPIO pins of the Raspi. These classes rely on `pigpio
<http://abyz.me.uk/rpi/pigpio/>`_, whose daemon (pigpiod) must be running in the background --
typically this is handled with a launch script/system daemon (see the launch_pilot.sh script generated by setup_pilot.py)

Note:
    This module does not include hardware that uses the GPIO pins over a specific protocol like i2c
"""
import sys
import threading
import time
import numpy as np
from datetime import datetime
import itertools


from autopilot import prefs
from autopilot.hardware import Hardware, BOARD_TO_BCM

ENABLED = False
try:
    import pigpio

    TRIGGER_MAP = {
        'U': pigpio.RISING_EDGE,
        1: pigpio.RISING_EDGE,
        True: pigpio.RISING_EDGE,
        'D': pigpio.FALLING_EDGE,
        0: pigpio.FALLING_EDGE,
        False: pigpio.FALLING_EDGE,
        'B': pigpio.EITHER_EDGE,
        (0,1): pigpio.EITHER_EDGE,
        [0,1]: pigpio.EITHER_EDGE
    }

    INVERSE_TRIGGER_MAP = {
        pigpio.RISING_EDGE: 'U',
        pigpio.FALLING_EDGE: 'D',
        pigpio.EITHER_EDGE: 'B'
    }
    """
    Inverse of TRIGGER_MAP. Used to assign canonical references to triggers -- 
    ie. it is possible to take multiple params -> pigpio objects, but one preferred
    way to refer to a pigpio object.
    """

    PULL_MAP = {
        'U': pigpio.PUD_UP,
        'D': pigpio.PUD_DOWN
    }



    ENABLED = True
except ImportError:
    # TODO: log
    ImportWarning("pigpio could not be imported, gpio not enabled")


class GPIO(Hardware):
    """
    Metaclass for hardware that uses GPIO. Should not be instantiated on its own.

    Handles initializing pigpio and wraps some of its commonly used methods

    Args:
        pin (int): The Board-numbered GPIO pin of this object.
        trigger_edge: The pigpio object representing RISING_EDGE, FALLING_EDGE, BOTH_EDGES. Set by :attr`.trigger`

    Attributes:
        pig (:class:`pigpio.pi`): An object that manages connection to the pigpio daemon. See docs at http://abyz.me.uk/rpi/pigpio/python.html
        CONNECTED (bool): Whether the connection to pigpio was successful
        pin_bcm (int): The BCM number of the connected pin -- used by pigpio. Converted from pin passed as argument on initialization, which is assumed to be the board number.
        pull (str, int): state of pullup/down resistor. Can be set as 'U'/'D' or 1/0 to pull up/down
        polarity (int): Logic direction. if 1: on=High=1, off=Low=0; if 0: off=Low=0, on=High=1
        on (int): if polarity == 1, high/1. if polarity == 0, low/0
        off (int): if polarity == 1, low/0. if polarity == 0, high/1
        trigger (str, 1): which
    """

    def __init__(self, pin=None, polarity=1, pull = None, trigger = None, **kwargs):
        super(GPIO, self).__init__(**kwargs)

        if not ENABLED:
            RuntimeError('Couldnt import pigpio, so GPIO objects cant be used')
            return

        # initialize attributes
        self._polarity = None
        self._pull = None
        self._pin = None
        self._trigger = None
        self.trigger_edge = None
        self.pin_bcm = None
        self.pig = None
        self.CONNECTED = False

        # set default attributes
        self.pin = pin
        self.polarity = polarity
        self.pull = pull
        self.trigger = trigger
        self.CONNECTED = self.init_pigpio()
        if not self.CONNECTED:
            RuntimeError('No connection could be made to the pigpio daemon')


    def init_pigpio(self):
        self.pig = pigpio.pi()
        if self.pig.connected:
            return True
        else:
            return False

    @property
    def pin(self):
        """
        Board-numbered GPIO pin.

        Only made a property so that if pin is changed pin_bcm is also changed
        """
        return self._pin

    @pin.setter
    def pin(self, pin):
        assert(int(pin))

        self._pin = int(pin)
        self.pin_bcm = BOARD_TO_BCM[self._pin]

    @property
    def pull(self):
        """
        State of pull

        Returns:
            int: 1/0/None for pulled up, down or not set.
        """
        return self._pull

    @pull.setter
    def pull(self, direction):

        if direction in (1, 'U', True):
            pull = pigpio.PUD_UP
            self._pull = 1
        elif direction in (0, 'D', False):
            pull = pigpio.PUD_DOWN
            self._pull = 0
        elif direction is None:
            pull = pigpio.PUD_OFF
            self._pull = None
        else:
            ValueError("pull must be one of 0/'D' for pulldown, 1/'U' for pullup, or None to clear")
            return

        self._pull = direction
        self.pig.set_pull_up_down(self.pin_bcm, pull)

    @property
    def polarity(self):
        """
        Logic direction. if 1: on=High=1, off=Low=0; if 0: off=Low=0, on=High=1.

        Only a property so on/off are set if changed
        """
        return self._polarity

    @polarity.setter
    def polarity(self, polarity):
        if polarity == 1:
            self.on = 1
            self.off = 0
        elif polarity == 0:
            self.on = 0
            self.off = 1
        else:
            ValueError('polarity must be 0 or 1')
            return

        self._polarity = polarity

    @property
    def trigger(self):
        """
        dict: Maps strings (('U',1,True), ('D',0,False), ('B',[0,1])) to pigpio edge types
        (RISING_EDGE, FALLING_EDGE, EITHER_EDGE), respectively.
        """
        return self._trigger


    @trigger.setter
    def trigger(self, trigger):
        # if trigger in ('U', 1, True):
        #     self._trigger = 'U'
        #     self.trigger_edge = pigpio.RISING_EDGE
        # elif trigger in ('D', 0, False):
        #     self._trigger = "D"
        #     self.trigger_edge = pigpio.FALLING_EDGE
        # elif trigger in ('B', [0,1], (0,1)):
        #     self._trigger = "D"
        #     self.trigger_edge = pigpio.EITHER_EDGE
        # else:
        #     ValueError('trigger must be one of U, D, B. instead got {}'.format(trigger))

        # TODO: test if this is equivalent to above (ie. does this work when key is (0,1)?)
        if trigger in TRIGGER_MAP.keys():
            self.trigger_edge = TRIGGER_MAP[trigger]
            self._trigger = INVERSE_TRIGGER_MAP[self.trigger_edge]
        else:
            ValueError('trigger must be one of {}. instead got {}'.format(INVERSE_TRIGGER_MAP.values(),
                                                                          trigger))

    def release(self):
        """
        Release the connection to the pigpio daemon.

        Note:
            the Hardware metaclass will call this method on object deletion.
        """
        self.pull = None
        self.pig.stop()


class Digital_Out(GPIO):
    """
    Send digital output pulses over a GPIO pin.

    Attributes:
        scripts (list): list of stored script handles
        pigs_function (bytes): when using pigpio scripts, what function is used to set the value of the output?
            (eg. 'w' for digital out, 'gdc' for pwm, more info here: http://abyz.me.uk/rpi/pigpio/pigs.html)
    """

    output = True
    type="DIGITAL_OUT"
    pigs_function = b"w"

    def __init__(self, pin=None, pulse_width=100, polarity=1, **kwargs):
        """
        Args:
            pin (int):
            pulse_width (int): Width of digital output pulse (us). range: 1-100
            polarity (bool): Whether 'on' is High (1, default) and pulses bring the voltage High, or vice versa (0)
        """
        super(Digital_Out, self).__init__(pin, polarity=polarity, **kwargs)

        self._last_script = None
        self.scripts = {}


        self.pulse_width = np.clip(pulse_width, 0, 100).astype(np.int)
        if pulse_width > 100 or pulse_width < 0:
            Warning('pulse_width must be <100(ms) & >0 and has been clipped to {}'.format(self.pulse_width))

        # setup pin
        if self.pin_bcm:
            self.pig.set_mode(self.pin_bcm, pigpio.OUTPUT)
            self.set(self.off)

    def set(self, value):
        """
        Thin wrapper around pig method used to set value. Default uses :meth:`pigpio.pi.write`, but can be overwritten by inheriting classes

        :param value:
        :return:
        """
        if self._last_script:
            status, _ = self.pig.script_status(self._last_script)
            if status == pigpio.PI_SCRIPT_RUNNING:
                self.pig.stop_script()

        self.pig.write(self.pin_bcm, value)

    def turn(self, direction='on'):
        """
        Change output state using on/off parlance. logic direction varies based on :attr:`.polarity`

        Args:
            direction (str, bool): 'on', 1, or True to turn to :attr:`self.on` and vice versa for :attr:`self.off
        """
        if direction in ('on', True, 1):
            self.set(self.on)
        elif direction in ('off', False, 0):
            self.set(self.off)

    def toggle(self):
        if self.pig.read(self.pin_bcm):
            self.set(0)
        else:
            self.set(1)


    def pulse(self, duration=None):

        if not duration:
            self.pig.gpio_trigger(self.pin_bcm, self.pulse_width, self.on)

        elif duration:
            duration = np.clip(duration, 0, 100).astype(np.int)
            self.pig.gpio_trigger(self.pin_bcm,
                                  duration,
                                  self.on)


    def _series_script(self, values, durations = None, unit="ms", repeat=None, finish_off = True):
        """
        Create a pigpio script to set a pin to a series of values for a series of durations.

        Args:
            values (list): A list of tuples of (value, duration) or a list of values in (1,0) to set self.pin_bcm to.
            durations (list): If values is not a list of tuples, a list of durations. len(durations) must be either == len(values) or else len(durations) == 1, in which case the duration is repeated.
            unit ("ms", "us"): units of durations in milliseconds or microseconds
            repeat (int): If the script should be repeated, how many times?
            finish_off (bool): If true, the script ends by turning the pin to self.off

        Returns:
            (str): constructed the function string
        """

        # if single value as an int/float/etc, wrap in list.
        if not isinstance(values, list) or isinstance(values, tuple):
            values = [values]


        if durations:
            if isinstance(durations, float) or isinstance(durations, int):
                durations = [round(durations)]

            if len(values) == len(durations):
                iter_series = itertools.izip(values, durations)
            if len(durations) == 1:
                iter_series = itertools.product(values, durations)
            else:
                ValueError("length of  values and durations must be equal, or length of durations must be 1. got len(values)={}, len(durations)={}".format(len(values), len(durations)))
        else:
            iter_series = values.__iter__()


        if unit == "ms":
            wait_fn = b"mils"
        elif unit == "us":
            wait_fn = b"mics"
        else:
            ValueError("Unit for durations must be ms (milliseconds) or us (microseconds)")

        string_pieces = [b" ".join((self.pigs_function, bytes(self.pin_bcm), bytes(val), wait_fn, bytes(dur))) for val, dur in iter_series]
        script_str = b" ".join(string_pieces)

        if repeat:
            try:
                repeat = int(repeat)
            except:
                ValueError('Repeat must be coerceable to an integer, got {}'.format(repeat))

            script_str = b" ".join(("LD v0", str(repeat-1), # "LD (load) variable 0 with number of repeats"
                                    "tag 999",            # create a tag that can be returned to
                                    script_str,           # do the script one time
                                    "dcr v0"              # decrement v0. 
                                    "jp 999")             # jump to the tag at the beginning if v0 is still positive
                                   )

        # turn off when finished
        if finish_off:
            script_str += b" ".join((self.pigs_function, bytes(self.pin_bcm), bytes(self.off)))


        return script_str

    def store_series(self, values, durations=None, unit="ms", repeat=None, finish_off = True, id=None):
        """

        Args:
            id (str): shorthand key used to call this series with :meth:`.series`
            values:
            durations:
            repeat:
            finish_off:

        Returns:

        """

        # actually might want to overwrite scripts w/ same ids, like a solenoid that changes its 'open' duration
        # if id in self.scripts.keys():
        #     Exception("Script with id {} already created!".format(id))

        series_script = self._series_script(values, durations, unit, repeat, finish_off)

        script_id = self.pig.store_script(series_script)

        if id:
            self.scripts[id] = script_id
        else:
            self.scripts[script_id] = script_id
            return script_id



    def series(self, values=None, durations=None, unit="ms", repeat=None, finish_off = True, store=False, id=None):
        """
        Shorthand way to set GPIO state for a series of durations.

        Ideally one would use :meth:`.store_script` and use the returned id to call this function.

        Otherwise, this method calls :meth:`.store_script` and runs it.

        Args:
            id (str, int): ID of the script, can be either the shorthand string id supplied to :meth:`.store_script` or the int returned by pigpio if you have it for some reason.
            values (list, tuple): Either a list of (value, duration_)
            durations:
            store (bool):

        Returns:

        """

        if id:
            if id in self.scripts.keys():
                self.pig.run_script(self.scripts[id])
                self._last_script = self.scripts[id]
            elif id in self.scripts.values():
                self.pig.run_script(id)
                self._last_script = id
            else:
                KeyError('Could not find script with id {}'.format(id))


            return

        # if we weren't called with an ID, have to have a list of values/etc to create a script
        if not values:
            RuntimeError('Must be called with either values or id!')

        # store and run script
        script = self.store_series(values, durations, unit, repeat, finish_off)
        self.pig.run_script(script)

        self._last_script = script

        if store:
            return script
        else:
            # TODO: Check if we need to spawn a timer to delete the script
            pass

    def stop_script(self, id=None):
        """
        Stops a running pigpio script
        Args:
            id (int, str, none): If None, stops the last run script. Otherwise tries to find a script with either key or pigpio id and stop that

        """

        if not id:
            id = self._last_script

        # if we were passed a keyed, named script id, convert it to the pigio integer script id
        if id in self.scripts.keys():
            id = self.scripts[id]

        self.pig.stop_script(id)

        self.set(self.off)



    def release(self):
        self.stop_script()
        self.set(self.off)
        super(Digital_Out, self).release()


class Digital_In(GPIO):
    """
    Record digital input and call one or more callbacks on logic transition.

    Attributes:
        pig (:meth:`pigpio.pi`): The pigpio connection.
        pin (int): Broadcom-numbered pin, converted from the argument given on instantiation
        callbacks (list): A list of :meth:`pigpio.callback`s kept to clear them on exit
        polarity (int): Logic direction, if 1: off=0, on=1, pull=low, trigger=high and vice versa for 0
        events (list): if :attr:`.record` is True, a list of tuple

            Note:
                pull and trigger are set by polarity on initialization in digital inputs, unlike other GPIO classes.
                They are not mutually synchronized however, ie. after initialization if any one of these attributes are changed, the other two will remain the same.
    """
    is_trigger=True
    type = 'DIGI_IN'
    input = True

    def __init__(self, pin, polarity=1, event=None, record=True, **kwargs):
        """
        Args:
            pin (int): Board-numbered pin, converted to BCM numbering during instantiation.
            pull_ud ('U', 'D', 'B'): Should this beambreak be pulled up or down?
            trigger_ud ('U', 'D', 'B'): Is the trigger event up (low to high) or down (high to low)?
            event (:class:`threading.Event`): We can be passed an Event object if we want to handle
                stage transition logic here instead of the :class:`.Task` object, as is typical.
            record (bool): Whether logic transitions should be recorded as a list of ('EVENT', 'Timestamp') tuples.
        """
        super(Digital_In, self).__init__(pin, polarity=polarity, **kwargs)

        # pull the resistor in the off direction and set the trigger to be the on direction
        self.pull = self.off
        self.trigger = self.on

        # We can be passed a threading.Event object if we want to handle stage logic here
        # rather than in the parent as is typical.
        self.event = event

        # List to store callback handles assigned with assign_cb
        self.callbacks = []

        # List to store logic transition events
        self.events = []

        self.record = record
        if self.record:
            self.assign_cb(self.record_event, add=True, evented=False, manual_trigger='B')

        # Setup pin
        self.pig.set_mode(self.pin_bcm, pigpio.INPUT)

    def assign_cb(self, callback_fn, add=True, evented=False, manual_trigger=None):
        """
        Sets `callback_fn` to be called when triggered.

        Args:
            callback_fn (callable): The function to be called when triggered
            add (bool): Are we adding another callback?
                If False, the previous callbacks are cleared.
            evented (bool): Should triggering this event also set the internal :attr:`~.Beambreak.event`?
                Note that :attr:`.Beambreak.event` must have been passed.
            manual_trigger ('U', 'D', 'B'): We can override :attr:`.Beambreak.trigger_ud` if needed.
        """
        # If we aren't adding, we clear any existing callbacks
        if not add:
            self.clear_cb()
            if self.record:
                # if we're clearing all callbacks (maybe by accident)
                # but we're configured to record events, re-add the record cb.
                self.assign_cb(self.record_event, add=True, evented=False, manual_trigger="B")

        # We can set the direction of the trigger manually,
        # for example if we want to set 'BOTH' only sometimes
        if not manual_trigger:
            trigger_ud = self.trigger_edge
        else:
            trigger_ud = TRIGGER_MAP[manual_trigger]

        # We can handle eventing (blocking) here if we want (usually this is handled in the parent)
        # This won't work if we weren't init'd with an event.
        if evented and self.event:
            cb = self.pig.callback(self.pin_bcm, trigger_ud, self.event.set)
            self.callbacks.append(cb)
        elif evented and not self.event:
            Exception('We have no internal event to set!')

        cb = self.pig.callback(self.pin_bcm, trigger_ud, callback_fn)
        self.callbacks.append(cb)

    def clear_cb(self):
        """
        Tries to call `.cancel()` on each of the callbacks in :attr:`Beambreak.callbacks`
        """
        for cb in self.callbacks:
            try:
                cb.cancel()
            except:
                pass
        self.callbacks = []

    def record_event(self, pin, level, tick):
        """
        On either direction of logic transition, record the time

        Args:
            pin (int): BCM numbered pin passed from pigpio
            level (bool): High/Low status of current pin
            tick (int): 32-bit integer, ticks since system start
        """

        # use self.pin rather than incoming pin b/c method is bound
        # (ie. only will be called by pin assigned to)
        # and self.pin is board rather than bcm numbered
        self.events.append((self.pin, level, tick))


    def release(self):
        self.clear_cb()
        super(Digital_In, self).release()

class PWM(Digital_Out):
    """
    PWM output from GPIO.
    """
    output = True
    type="PWM"
    pigs_function = b'pwm'

    def __init__(self, pin, polarity=1, range=255, **kwargs):
        """

        :param pin:
        :param polarity:
        """

        super(PWM, self).__init__(pin, **kwargs)
        self._range = None
        self.polarity = polarity
        self.range = range

        #self.pig.set_mode(self.pin_bcm, pigpio.OUTPUT)
        # set to off in case of common anode/inverted polarity
        self.set(self.off)

    def set(self, value):
        """
        Sets PWM duty cycle normalized to :attr:`.polarity`

        Args:
            value (int, float):
                - if int > 1, sets value (or :attr:`.range`-value if :attr:`.polarity` is inverted).
                - if float > 0, < 1, transforms to a proportion of :attr:`.range` (inverted  if needed as well).

        """
        value = self._clean_value(value)

        if self._last_script:
            status, _ = self.pig.script_status(self._last_script)
            if status in (pigpio.PI_SCRIPT_RUNNING):
                self.pig.stop_script(self._last_script)

        self.pig.set_PWM_dutycycle(self.pin_bcm, value)

    def _clean_value(self, value):
        if value > 1:
            if value > self.range:
                Warning('clipping {} to range {}'.format(value, self.range))
                value = np.clip(value, 0, self.range).astype(np.int)

        elif 0 <= value <= 1:
            value = np.round(value * self.range).astype(np.int)

        else:
            ValueError('PWM value must be an integer between 0 and range: {}, or a float between 0 and 1. got {}'.format(self.range, value))

        if self.polarity == 0:
            value = self.range - value

        return value




    @property
    def range(self):
        if not self._range:
            self._range = self.pig.get_pwm_range(self.pin_bcm)

        return self._range

    @range.setter
    def range(self, value):
        try:
            value = int(value)
        except ValueError:
            ValueError('PWM Range must be coerceable to an integer, got {}'.format(value))

        if (value < 25) or (value > 40000):
            Warning('PWM Range must be between 25 and 40000, got {}, clipping to range'.format(value))
            value = np.clip(value, 25, 40000).astype(np.int)

        self.pig.set_PWM_range(self.pin_bcm, value)
        self._range = value

        # set polarity again so off/on update
        self.polarity = self._polarity


    @property
    def polarity(self):
        """
        Logic direction. if 1: on=High=255, off=Low=0; if 0: off=Low=0, on=High=255.

        Only a property so on/off are set if changed
        """
        return self._polarity

    @polarity.setter
    def polarity(self, polarity):
        if polarity == 1:
            self.on = self.range
            self.off = 0
        elif polarity == 0:
            self.on = 0
            self.off = self.range
        else:
            ValueError('polarity must be 0 or 1')
            return

        self._polarity = polarity



    def release(self):
        super(PWM, self).release()


class LED_RGB(Digital_Out):

    output = True
    type = "LEDS"

    def __init__(self, pins = None, r = None, g = None, b = None, polarity = 1, blink = True, **kwargs):
        """
        Args:
            pins (list): A list of (board) pin numbers.
                Either `pins` OR all `r`, `g`, `b` must be passed.
            r (int): Board number of Red pin - must be passed with `g` and `b`
            g (int): Board number of Green pin - must be passed with `r` and `b`
            b (int): Board number of Blue pin - must be passed with `r` and `g`:
            polarity (0, 1):
                0: common anode (low turns LED on)
                1: common cathode (low turns LED off)
            blink (bool): Flash RGB at the end of init to show we're alive and bc it's real cute.
        """


        super(LED_RGB, self).__init__(**kwargs)

        # self._pin = {}
        self.channels = {}
        self.scripts = {}

        if pins and len(pins) == 3:
            for color, pin in zip(('r', 'g', 'b'), pins):
                self.channels[color] = PWM(pin, polarity=polarity)

        elif r and g and b:
            self.channels = {'r':PWM(r, polarity=polarity),
                             'g':PWM(g, polarity=polarity),
                             'b':PWM(b, polarity=polarity)}
        else:
            ValueError('Must either set with pins= list/tuple of r,g,b pins, or pass all three as separate params')

        if blink:
            self.series(((1,0,0),(0,1,0),(0,0,1),(0,0,0)),250)

    def set(self, value=None, r=None, g=None, b=None):
        if self._last_script:
            status, _ = self.pig.script_status(self._last_script)
            if status == pigpio.PI_SCRIPT_RUNNING:
                self.pig.stop_script()

        # if we were given a value, ignore other arguments
        if value:
            if isinstance(value, int) or isinstance(value, float):
                for channel in self.channels.values():
                    channel.set(value)
            elif len(value) == 3:
                for channel_key, color_val in zip(('r','g','b'), value):
                    self.channels[channel_key].set(value)
            else:
                ValueError('Value must either be a single value or a tuple of (r,g,b)')
        else:
            if r:
                self.channels['r'].set(r)
            if g:
                self.channels['g'].set(g)
            if b:
                self.channels['b'].set(b)

    def toggle(self):
        Warning('toggle not well defined for PWM')

    def pulse(self, duration=None):
        Warning('Use flash for LEDs instead')




    def _series_script(self, colors, durations = None, unit="ms", repeat=None, finish_off = True):

        if durations:
            if isinstance(durations, int) or isinstance(durations, float):
                iter_series = itertools.product(colors, [round(durations)])
            elif len(colors) == len(durations):
                iter_series = itertools.izip(colors, durations)
            elif len(durations) == 1:
                iter_series = itertools.product(colors, durations)
            else:
                ValueError("length of  colors and durations must be equal, or length of durations must be 1. got len(colors)={}, len(durations)={}".format(len(colors), len(durations)))
        else:
            iter_series = colors.__iter__()

        if unit == "ms":
            wait_fn = b"mils"
        elif unit == "us":
            wait_fn = b"mics"
        else:
            ValueError("Unit for durations must be ms (milliseconds) or us (microseconds)")


        string_pieces = []
        for color, duration in iter_series:
            # iter over keys rather than values of channels dict b/c dicts are unordered and colors are an ordered tuple
            for channel_key, color_value in zip(('r', 'g', 'b'), color):
                string_pieces.append(b" ".join((self.channels[channel_key].pigs_function,
                                               bytes(self.channels[channel_key].pin_bcm),
                                               bytes(self.channels[channel_key]._clean_value(color_value)))))
            string_pieces.append(bytes("{} {}".format(wait_fn, bytes(duration))))

        script_str = b" ".join(string_pieces)

        if repeat:
            try:
                repeat = int(repeat)
            except:
                ValueError('Repeat must be coerceable to an integer, got {}'.format(repeat))

            script_str = b" ".join(("LD v0", str(repeat-1), # "LD (load) variable 0 with number of repeats"
                                    "tag 999",            # create a tag that can be returned to
                                    script_str,           # do the script one time
                                    "dcr v0"              # decrement v0. 
                                    "jp 999")             # jump to the tag at the beginning if v0 is still positive
                                   )

        # turn off when finished
        if finish_off:
            #script_str += b" "
            finish_pieces = [script_str]
            for channel in self.channels.values():
                finish_pieces.append(b" ".join((channel.pigs_function, bytes(channel.pin_bcm), bytes(channel.off))))
            script_str = b" ".join(finish_pieces)

        return script_str

    def flash(self, duration, frequency=10, colors=((1,1,1),(0,0,0))):
        """
        Specify a color series by total duration and flash frequency.

        Largely a convenience function for on/off flashes.

        Args:
            duration (int, float): Duration of flash in ms.
            frequency (int, float): Frequency of flashes in Hz
            colors (list): A list of RGB values 0-255 like::

                [[255,255,255],[0,0,0]]

        """
        # Duration is total in ms, frequency in Hz
        # Get number of flashes in duration rounded down

        n_rep = int(float(duration) / 1000. * float(frequency))
        flashes = colors * n_rep

        # Invert frequency to duration for single flash
        # divide by 2 b/c each 'color' is half the duration
        single_dur = ((1. / frequency) * 1000) / 2.
        self.series(flashes, single_dur)
    #
    # def __getattr__(self, name):
    #     """if a method is called that we don't explicitly redefine, try to apply it to each of our channels"""
    #
    #     attrs = {color: object.__getattribute__(chan, name) for color, chan in self.channels.items()}
    #     if hasattr(list(attrs.values())[0], '__call__'):
    #         def newfunc(*args, **kwargs):
    #             result = {}
    #             # if called with a dictionary of {'r':params, 'g':params, ...}, call that explicitly
    #             if isinstance(args[0], dict):
    #                 if any([k in args[0].keys() for k in self.channels.keys()]):
    #                     for color, method in attrs.items():
    #                         if color in args[0].keys():
    #                             result[color] = method(**args[0][color])
    #                     return result
    #
    #             # otherwise, call all channels with the same argument
    #             for color, method in attrs.items():
    #                 result[color] = method(*args, **kwargs)
    #             return result
    #
    #         return newfunc
    #     else:
    #         return attrs

    def release(self):
        for chan in self.channels.values():
            chan.release()
        self.pig.stop()


    @property
    def pin(self):
        return {'r':self.channels['r'].pin,
                'g':self.channels['g'].pin,
                'b':self.channels['b'].pin}

    @property
    def pin_bcm(self):
        return {'r':self.channels['r'].pin_bcm,
                'g':self.channels['g'].pin_bcm,
                'b':self.channels['b'].pin_bcm}

class Solenoid(Digital_Out):
    """
    Solenoid valves for water delivery.

    Only NC solenoids should be used, as there is no way to guarantee
    that a pin will maintain its voltage when it is released, and you will
    spill water all over the place.
    """

    output = True
    type = "PORTS"
    DURATION_MIN = 2 #ms


    def __init__(self, pin, polarity=1, duration=20, vol=None):
        """
        Args:
            pin (int): Board pin number, converted to BCM on init.
            duration (int, float): duration of open, ms.
            vol (int, float): desired volume of reward in uL, must have computed calibration results, see :method:`~autopilot.core.terminal.Terminal.calibrate_ports`
        """
        super(Solenoid, self).__init__(pin, polarity=polarity)
        self.calibration = None
        self._duration = None

        # Pigpio has us create waves to deliver timed output
        # Since we typically only use one duration,
        # we make the wave once and only make it again when asked to
        # We start with passed or default duration (ms)
        if vol:
            self.duration = self.dur_from_vol(vol)
            self.mode = 'VOLUME'

        else:
            self.duration = duration
            self.mode='DURATION'

    @property
    def duration(self):
        return self._duration

    @duration.setter
    def duration(self, duration):
        duration = round(duration)
        if duration < self.DURATION_MIN:
            Warning('Duration cannot be less than {}, so value was clipped. given {}'.format(self.DURATION_MIN, duration))
            duration = self.DURATION_MIN

        self._duration = duration
        self.store_series(self.on, self._duration, id="open", unit="ms", finish_off=True, repeat=None)



    def dur_from_vol(self, vol):
        """
        Given a desired volume, set our open duration.

        Args:
            vol (float, int): desired reward volume in uL

        Returns:

        """
        # find our pin name
        if not self.name:
            self.name = self.get_name()

        # prefs should have loaded any calibration
        self.calibration = prefs.PORT_CALIBRATION[self.name]

        # compute duration from slope and intercept
        duration = round(float(self.calibration['intercept']) + (float(self.calibration['slope']) * float(vol)))

        return duration


    def open(self, duration=None):
        """
        Open the valve.

        Args:
            duration (float): If provided, open for this duration instead of
                the duration stored on instantiation.
        """
        if duration:
            self.duration = duration

        self.series(id="open")



#
#
# class old_LED_RGB(Hardware):
#     # TODO: Refactor to use three PWM objects
#     """
#     An RGB LED.
#
#     Attributes:
#         pig (:meth:`pigpio.pi`): The pigpio connection.
#         flash_block (:class:`threading.Event`): An Event to wait on setting further colors
#             if we are currently in a threaded flash train
#         end_thread (:class:`threading.Event`): Set this event to stop a flash train - usually called during object cleanup
#         pins (dict): After init, pin numbers are kept in a dict like::
#
#             {'r':bcm_number, 'g':...}
#
#         stored_color (dict): A color we store to restore after we do a flash train.
#
#     """
#
#     output = True
#     type="LEDS"
#
#     def __init__(self, pins = None, r = None, g=None, b=None, common = 'anode', blink=True):
#         """
#         Args:
#             pins (list): A list of (board) pin numbers.
#                 Either `pins` OR all `r`, `g`, `b` must be passed.
#             r (int): Board number of Red pin - must be passed with `g` and `b`
#             g (int): Board number of Green pin - must be passed with `r` and `b`
#             b (int): Board number of Blue pin - must be passed with `r` and `g`:
#             common ('anode', 'cathode'): Is this LED common anode (low turns LED on)
#                 or cathode (low turns LED off)
#             blink (bool): Flash RGB at the end of init to show we're alive.
#         """
#         self.common = common
#
#         # Dict to store color for after flash trains
#         self.stored_color = {}
#
#         # Event to wait on setting colors if we're flashing
#         self.flash_block = threading.Event()
#         self.flash_block.set()
#
#         # Event to kill the flash thread if the object is deleted
#         self.end_thread = threading.Event()
#         self.end_thread.clear()
#
#         # Initialize connection to pigpio daemon
#         self.pig = pigpio.pi()
#         if not self.pig.connected:
#             Exception('No connection to pigpio daemon could be made')
#
#         # Unpack input
#         self.pins = {}
#         if r and g and b:
#             self.pins['r'] = int(r)
#             self.pins['g'] = int(g)
#             self.pins['b'] = int(b)
#         elif isinstance(pins, list):
#             self.pins['r'] = int(pins[0])
#             self.pins['g'] = int(pins[1])
#             self.pins['b'] = int(pins[2])
#         else:
#             Exception('Dont know how to handle input to LED_RGB')
#
#         # Convert to BCM numbers
#         self.pins = {k: BOARD_TO_BCM[v] for k, v in self.pins.items()}
#
#         # set pin mode to output and make sure they're turned off
#         for pin in self.pins.values():
#             self.pig.set_mode(pin, pigpio.OUTPUT)
#             if self.common == 'anode':
#                 self.pig.set_PWM_dutycycle(pin, 255)
#             elif self.common == 'cathode':
#                 self.pig.set_PWM_dutycycle(pin, 0)
#             else:
#                 Exception('Common passed to LED_RGB not anode or cathode')
#
#         # Blink to show we're alive
#         if blink:
#             self.color_series([[255,0,0],[0,255,0],[0,0,255],[0,0,0]], 250)
#
#     def __del__(self):
#         self.release()
#
#
#     def release(self):
#         """
#         Turns LED off and releases pigpio.
#         """
#         self.end_thread.set()
#         self.set_color(col=[0,0,0])
#         self.pig.stop()
#
#     def set_color(self, col=None, r=None, g=None, b=None, timed=None, stored=False, internal=False):
#         """
#         Set the color of the LED.
#
#         Note:
#             if called during a :meth:`LED_RGB.color_series`, the color will be stashed and set when the train is over.
#
#         Args:
#             col (list, tuple): an RGB color trio ranging from 0-255. Either `col` or all of `r`, `g`, `b` must be provided
#             r (int): Red intensity 0-255. Must be passed with `g` and `b`
#             g (int): Green intensity 0-255. Must be passed with `r` and `b`
#             b (int): Blue intensity 0-255. Must be passed with `r` and `g`
#             timed (float): Duration to change to this color before turning off in ms.
#             stored (bool): Called internally to change back to the color that preceded a flash train. Restores :attr:`LED_RGB.stored_color`.
#             internal (bool): True if being called inside a flash train.
#         """
#         if stored:
#             # being called after a flash train
#             # Since this is always called after a flash train, check that we were actually assigned a color
#             if self.stored_color:
#                 color = self.stored_color
#                 self.stored_color = {}
#             else:
#                 # It's fine not to have a color, just return quietly.
#                 return
#         else:
#             # Unpack input
#             if r and g and b:
#                 color = {'r':int(r), 'g':int(g), 'b':int(b)}
#             elif isinstance(col, list) or isinstance(col, tuple):
#                 color = {'r':int(col[0]), 'g':int(col[1]), 'b':int(col[2])}
#             else:
#                 Warning('Color improperly formatted')
#                 return
#
#         # If we're flashing or doing a color series, stash the color and we'll set it after the flash is done
#         # the 'internal' flag checks if this is being called within a flash train
#         if not internal and not self.flash_block.is_set():
#             self.stored_color = color
#             return
#
#         # Set PWM dutycycle
#         try:
#             if self.common == 'anode':
#                 for k, v in color.items():
#                     self.pig.set_PWM_dutycycle(self.pins[k], 255-v)
#             elif self.common == 'cathode':
#                 for k, v in color.items():
#                     self.pig.set_PWM_dutycycle(self.pins[k], v)
#         except AttributeError:
#             # if object has been cleaned up and a lingering set_color command remains,
#             # pigpio will throw an attribute error because its interface has been deleted
#             # we can return peacefully
#             # TODO: Log this
#             return
#
#         # If this is is a timed blink, start thread to turn led off
#         if timed:
#             # timed should be a float or int specifying the delay in ms
#             offtimer = threading.Timer(float(timed)/1000, self.set_color, kwargs={'col':[0,0,0]})
#             offtimer.start()
#
#     def flash(self, duration, frequency=10, colors=[[255,255,255],[0,0,0]]):
#         """
#         Specify a color series by total duration and flash frequency.
#
#         Largely a convenience function for on/off flashes.
#
#         Args:
#             duration (int, float): Duration of flash in ms.
#             frequency (int, float): Frequency of flashes in Hz
#             colors (list): A list of RGB values 0-255 like::
#
#                 [[255,255,255],[0,0,0]]
#
#         """
#         # Duration is total in ms, frequency in Hz
#         # Get number of flashes in duration rounded down
#
#         n_rep = int(float(duration)/1000.*float(frequency))
#         flashes = colors*n_rep
#
#         # Invert frequency to duration for single flash
#         # divide by 2 b/c each 'color' is half the duration
#         single_dur = ((1./frequency)*1000)/2.
#         self.color_series(flashes, single_dur)
#
#     def color_series(self, colors, duration):
#         """
#         Change color through a series for a fixed duration.
#
#         Wrapper around :meth:`LED_RGB.threaded_color_series`
#
#         Args:
#             colors (list): A list of RGB values 0-255 like::
#
#                 [[255,255,255],[0,0,0]]
#
#             duration (int, list): Either a single duration (int, ms)
#                 or list of ints of equal length to `colors` to define
#                 duration for each.
#         """
#         # Just a wrapper to make threaded
#         series_thread = threading.Thread(target=self.threaded_color_series, kwargs={'colors':colors, 'duration':duration})
#         series_thread.start()
#
#     def threaded_color_series(self, colors, duration):
#         """
#         Should only be called by :meth:`.LED_RGB.color_series` because it blocks.
#
#         Clears :attr:`.LED_RGB.flash_block` , sets colors, sleeps, sets the block, and
#         then sets any color that was passed during the train.
#
#         Args:
#             colors (list): A list of RGB values 0-255 like::
#
#                 [[255,255,255],[0,0,0]]
#
#             duration (int, list): Either a single duration (int, ms)
#                 or list of ints of equal length to `colors` to define
#                 duration for each.
#         """
#         self.flash_block.clear()
#         if isinstance(duration, int) or isinstance(duration, float):
#             for c in colors:
#                 if self.end_thread.is_set():
#                     return
#                 self.set_color(c, internal=True)
#                 time.sleep(float(duration)/1000)
#         elif isinstance(duration, list) and (len(colors) == len(duration)):
#             for i, c in enumerate(colors):
#                 if self.end_thread.is_set():
#                     return
#                 self.set_color(c, internal=True)
#                 time.sleep(float(duration[i])/1000)
#         else:
#             Exception("Dont know how to handle your color series")
#             return
#         self.flash_block.set()
#         # If we received a color command while we were doing the series, set it now.
#         # We call the function regardless, it will switch to a color if it has one
#         self.set_color(stored=True)
