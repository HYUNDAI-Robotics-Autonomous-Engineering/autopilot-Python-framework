"""
Hardware that uses the GPIO pins of the Raspi. These classes rely on `pigpio
<http://abyz.me.uk/rpi/pigpio/>`_, whose daemon (pigpiod) must be running in the background --
typically this is handled with a launch script/system daemon (see the launch_pilot.sh script generated by setup_pilot.py)

Note:
    This module does not include hardware that uses the GPIO pins over a specific protocol like i2c
"""
import sys
import threading
import time
import numpy as np

import pigpio

from autopilot import prefs
from autopilot.hardware import Hardware, BOARD_TO_BCM, TRIGGER_MAP, PULL_MAP


class GPIO(Hardware):
    """
    Metaclass for hardware that uses GPIO. Should not be instantiated on its own.

    Handles initializing pigpio and wraps some of its commonly used methods

    Args:
        pin (int): The Board-numbered GPIO pin of this object.

    Attributes:
        pig (:class:`pigpio.pi`): An object that manages connection to the pigpio daemon. See docs at http://abyz.me.uk/rpi/pigpio/python.html
        CONNECTED (bool): Whether the connection to pigpio was successful
        pin_bcm (int): The BCM number of the connected pin -- used by pigpio. Converted from pin passed as argument on initialization, which is assumed to be the board number.
        pull (str, int): state of pullup/down resistor. Can be set as 'U'/'D' or 1/0 to pull up/down
    """

    def __init__(self, pin, pull_ud = None):
        super(GPIO, self).__init__()

        self._pull = None
        self._pin = None
        self.pin_bcm = None
        self.pig = None
        self.CONNECTED = False

        self.pin = pin
        self.CONNECTED = self.init_pigpio()

        if pull_ud:
            self.pull = pull_ud


    def init_pigpio(self):
        self.pig = pigpio.pi()
        if self.pig.connected:
            return True
        else:
            return False

    @property
    def pin(self):
        """
        Board-numbered GPIO pin.

        Only made a property so that if pin is changed pin_bcm is also changed
        """
        return self._pin

    @pin.setter
    def pin(self, pin):
        assert(int(pin))

        self._pin = int(pin)
        self.pin_bcm = BOARD_TO_BCM[self._pin]

    @property
    def pull(self):
        """
        State of pull

        Returns:
            int: 1/0/None for pulled up, down or not set.
        """
        return self._pull

    @pull.setter
    def pull(self, direction):
        if direction in (1, 'U'):
            pull = pigpio.PUD_UP
            self._pull = 1
        elif direction in (0, 'D'):
            pull = pigpio.PUD_DOWN
            self._pull = 0
        elif direction is None:
            pull = pigpio.PUD_OFF
            self._pull = None
        else:
            ValueError("pull must be one of 0/'D' for pulldown, 1/'U' for pullup, or None to clear")
            return

        self.pig.set_pull_up_down(self.pin_bcm, pull)


    def release(self):
        """
        Release the connection to the pigpio daemon.

        Note:
            the Hardware metaclass will call this method on object deletion.
        """
        self.pig.stop()

# TODO: Jonny stopping here after making metaclass, before fixing derivative classes 1/20/20


class Digital_Out(GPIO):
    """
    Send digital output pulses over a GPIO pin.

    """

    output = True
    type="DIGITAL_OUT"

    def __init__(self, pin, pulse_width=100, polarity=False):
        """
        Args:
            pin (int):
            pulse_width (int): Width of digital output pulse (us). range: 1-100
            polarity (bool): Whether 'off' is Low (False, default) and pulses bring the voltage High, or vice versa (True)
        """
        super(Digital_Out, self).__init__(pin)


        self.pulse_width = np.clip(pulse_width, 0, 100).astype(np.int)

        # get logic direction
        self.on = 1
        self.off = 0
        self.polarity = polarity
        if not self.polarity:
            self.on = 0
            self.off = 1

        # setup pin
        self.pig.set_mode(self.pin, pigpio.OUTPUT)
        self.pig.write(self.pin, self.off)

    def pulse(self, duration=None):

        if not duration:
            self.pig.gpio_trigger(self.pin, self.pulse_width, self.on)

        elif duration:
            duration = np.clip(duration, 0, 100).astype(np.int)
            self.pig.gpio_trigger(self.pin,
                                  duration,
                                  self.on)

    def release(self):
        self.pig.write(self.pin, 0)
        self.pig.stop()

class Beambreak(Hardware):
    """
    An IR Beambreak sensor.

    A phototransistor that changes voltage from 'high' to 'low' or vice versa
    when light is blocked.

    Attributes:
        pig (:meth:`pigpio.pi`): The pigpio connection.
        pin (int): Broadcom-numbered pin, converted from the argument given on instantiation
        callbacks (list): A list of :meth:`pigpio.callback`s kept to clear them on exit
    """
    trigger=True
    type = 'POKES'
    input = True

    def __init__(self, pin, pull_ud='U', trigger_ud='D', event=None):
        """
        Args:
            pin (int): Board-numbered pin, converted to BCM numbering during instantiation.
            pull_ud ('U', 'D', 'B'): Should this beambreak be pulled up or down?
            trigger_ud ('U', 'D', 'B'): Is the trigger event up (low to high) or down (high to low)?
            event (:class:`threading.Event`): We can be passed an Event object if we want to handle
                stage transition logic here instead of the :class:`.Task` object, as is typical.
        """

        self.trigger = True
        self.type = 'POKES'
        self.input = True

        # Make pigpio instance
        self.pig = pigpio.pi()

        # Convert pin from board to bcm numbering
        self.pin = BOARD_TO_BCM[int(pin)]

        try:
            self.pull_ud = PULL_MAP[pull_ud]
        except KeyError:
            Exception('pull_ud must be one of {}, was given {}'.format(PULL_MAP.keys(), pull_ud))

        try:
            self.trigger_ud = TRIGGER_MAP[trigger_ud]
        except KeyError:
            Exception('trigger_ud must be one of {}, was given {}'.format(TRIGGER_MAP.keys(), trigger_ud))

        # We can be passed a threading.Event object if we want to handle stage logic here
        # rather than in the parent as is typical.
        self.event = event

        # List to store callback handles
        self.callbacks = []

        # Setup pin
        self.pig.set_mode(self.pin, pigpio.INPUT)
        self.pig.set_pull_up_down(self.pin, self.pull_ud)

    def __del__(self):
        self.pig.stop()

    def release(self):
        """
        Simply calls `self.pig.stop()` to release pigpio resources.
        """
        self.pig.stop()

    def assign_cb(self, callback_fn, add=False, evented=False, manual_trigger=None):
        """
        Sets `callback_fn` to be called when triggered.

        Args:
            callback_fn (callable): The function to be called when triggered
            add (bool): Are we adding another callback?
                If False, the previous callbacks are cleared.
            evented (bool): Should triggering this event also set the internal :attr:`~.Beambreak.event`?
                Note that :attr:`.Beambreak.event` must have been passed.
            manual_trigger ('U', 'D', 'B'): We can override :attr:`.Beambreak.trigger_ud` if needed.
        """
        # If we aren't adding, we clear any existing callbacks
        if not add:
            self.clear_cb()

        # We can set the direction of the trigger manually,
        # for example if we want to set 'BOTH' only sometimes
        if not manual_trigger:
            trigger_ud = self.trigger_ud
        else:
            trigger_ud = TRIGGER_MAP[manual_trigger]

        # We can handle eventing (blocking) here if we want (usually this is handled in the parent)
        # This won't work if we weren't init'd with an event.
        if evented and self.event:
            cb = self.pig.callback(self.pin, trigger_ud, self.event.set)
            self.callbacks.append(cb)
        elif evented and not self.event:
            Exception('We have no internal event to set!')

        cb = self.pig.callback(self.pin, trigger_ud, callback_fn)
        self.callbacks.append(cb)

    def clear_cb(self):
        """
        Tries to call `.cancel()` on each of the callbacks in :attr:`Beambreak.callbacks`
        """
        for cb in self.callbacks:
            try:
                cb.cancel()
            except:
                pass
        self.callbacks = []


class Flag(Beambreak):
    """
    Trivial Reclass of the Beambreak class with the default directions reversed.

    TODO:
        Need to add argument passing into hardware spec so we don't need stuff like this


    """
    trigger = True

    def __init__(self, pin):
        super(Flag, self).__init__(pin, pull_ud="D", trigger_ud="U")


class LED_RGB(Hardware):
    """
    An RGB LED.

    Attributes:
        pig (:meth:`pigpio.pi`): The pigpio connection.
        flash_block (:class:`threading.Event`): An Event to wait on setting further colors
            if we are currently in a threaded flash train
        end_thread (:class:`threading.Event`): Set this event to stop a flash train - usually called during object cleanup
        pins (dict): After init, pin numbers are kept in a dict like::

            {'r':bcm_number, 'g':...}

        stored_color (dict): A color we store to restore after we do a flash train.

    """

    output = True
    type="LEDS"

    def __init__(self, pins = None, r = None, g=None, b=None, common = 'anode', blink=True):
        """
        Args:
            pins (list): A list of (board) pin numbers.
                Either `pins` OR all `r`, `g`, `b` must be passed.
            r (int): Board number of Red pin - must be passed with `g` and `b`
            g (int): Board number of Green pin - must be passed with `r` and `b`
            b (int): Board number of Blue pin - must be passed with `r` and `g`:
            common ('anode', 'cathode'): Is this LED common anode (low turns LED on)
                or cathode (low turns LED off)
            blink (bool): Flash RGB at the end of init to show we're alive.
        """
        self.common = common

        # Dict to store color for after flash trains
        self.stored_color = {}

        # Event to wait on setting colors if we're flashing
        self.flash_block = threading.Event()
        self.flash_block.set()

        # Event to kill the flash thread if the object is deleted
        self.end_thread = threading.Event()
        self.end_thread.clear()

        # Initialize connection to pigpio daemon
        self.pig = pigpio.pi()
        if not self.pig.connected:
            Exception('No connection to pigpio daemon could be made')

        # Unpack input
        self.pins = {}
        if r and g and b:
            self.pins['r'] = int(r)
            self.pins['g'] = int(g)
            self.pins['b'] = int(b)
        elif isinstance(pins, list):
            self.pins['r'] = int(pins[0])
            self.pins['g'] = int(pins[1])
            self.pins['b'] = int(pins[2])
        else:
            Exception('Dont know how to handle input to LED_RGB')

        # Convert to BCM numbers
        self.pins = {k: BOARD_TO_BCM[v] for k, v in self.pins.items()}

        # set pin mode to output and make sure they're turned off
        for pin in self.pins.values():
            self.pig.set_mode(pin, pigpio.OUTPUT)
            if self.common == 'anode':
                self.pig.set_PWM_dutycycle(pin, 255)
            elif self.common == 'cathode':
                self.pig.set_PWM_dutycycle(pin, 0)
            else:
                Exception('Common passed to LED_RGB not anode or cathode')

        # Blink to show we're alive
        if blink:
            self.color_series([[255,0,0],[0,255,0],[0,0,255],[0,0,0]], 250)

    def __del__(self):
        self.release()


    def release(self):
        """
        Turns LED off and releases pigpio.
        """
        self.end_thread.set()
        self.set_color(col=[0,0,0])
        self.pig.stop()

    def set_color(self, col=None, r=None, g=None, b=None, timed=None, stored=False, internal=False):
        """
        Set the color of the LED.

        Note:
            if called during a :meth:`LED_RGB.color_series`, the color will be stashed and set when the train is over.

        Args:
            col (list, tuple): an RGB color trio ranging from 0-255. Either `col` or all of `r`, `g`, `b` must be provided
            r (int): Red intensity 0-255. Must be passed with `g` and `b`
            g (int): Green intensity 0-255. Must be passed with `r` and `b`
            b (int): Blue intensity 0-255. Must be passed with `r` and `g`
            timed (float): Duration to change to this color before turning off in ms.
            stored (bool): Called internally to change back to the color that preceded a flash train. Restores :attr:`LED_RGB.stored_color`.
            internal (bool): True if being called inside a flash train.
        """
        if stored:
            # being called after a flash train
            # Since this is always called after a flash train, check that we were actually assigned a color
            if self.stored_color:
                color = self.stored_color
                self.stored_color = {}
            else:
                # It's fine not to have a color, just return quietly.
                return
        else:
            # Unpack input
            if r and g and b:
                color = {'r':int(r), 'g':int(g), 'b':int(b)}
            elif isinstance(col, list) or isinstance(col, tuple):
                color = {'r':int(col[0]), 'g':int(col[1]), 'b':int(col[2])}
            else:
                Warning('Color improperly formatted')
                return

        # If we're flashing or doing a color series, stash the color and we'll set it after the flash is done
        # the 'internal' flag checks if this is being called within a flash train
        if not internal and not self.flash_block.is_set():
            self.stored_color = color
            return

        # Set PWM dutycycle
        try:
            if self.common == 'anode':
                for k, v in color.items():
                    self.pig.set_PWM_dutycycle(self.pins[k], 255-v)
            elif self.common == 'cathode':
                for k, v in color.items():
                    self.pig.set_PWM_dutycycle(self.pins[k], v)
        except AttributeError:
            # if object has been cleaned up and a lingering set_color command remains,
            # pigpio will throw an attribute error because its interface has been deleted
            # we can return peacefully
            # TODO: Log this
            return

        # If this is is a timed blink, start thread to turn led off
        if timed:
            # timed should be a float or int specifying the delay in ms
            offtimer = threading.Timer(float(timed)/1000, self.set_color, kwargs={'col':[0,0,0]})
            offtimer.start()

    def flash(self, duration, frequency=10, colors=[[255,255,255],[0,0,0]]):
        """
        Specify a color series by total duration and flash frequency.

        Largely a convenience function for on/off flashes.

        Args:
            duration (int, float): Duration of flash in ms.
            frequency (int, float): Frequency of flashes in Hz
            colors (list): A list of RGB values 0-255 like::

                [[255,255,255],[0,0,0]]

        """
        # Duration is total in ms, frequency in Hz
        # Get number of flashes in duration rounded down

        n_rep = int(float(duration)/1000.*float(frequency))
        flashes = colors*n_rep

        # Invert frequency to duration for single flash
        # divide by 2 b/c each 'color' is half the duration
        single_dur = ((1./frequency)*1000)/2.
        self.color_series(flashes, single_dur)

    def color_series(self, colors, duration):
        """
        Change color through a series for a fixed duration.

        Wrapper around :meth:`LED_RGB.threaded_color_series`

        Args:
            colors (list): A list of RGB values 0-255 like::

                [[255,255,255],[0,0,0]]

            duration (int, list): Either a single duration (int, ms)
                or list of ints of equal length to `colors` to define
                duration for each.
        """
        # Just a wrapper to make threaded
        series_thread = threading.Thread(target=self.threaded_color_series, kwargs={'colors':colors, 'duration':duration})
        series_thread.start()

    def threaded_color_series(self, colors, duration):
        """
        Should only be called by :meth:`.LED_RGB.color_series` because it blocks.

        Clears :attr:`.LED_RGB.flash_block` , sets colors, sleeps, sets the block, and
        then sets any color that was passed during the train.

        Args:
            colors (list): A list of RGB values 0-255 like::

                [[255,255,255],[0,0,0]]

            duration (int, list): Either a single duration (int, ms)
                or list of ints of equal length to `colors` to define
                duration for each.
        """
        self.flash_block.clear()
        if isinstance(duration, int) or isinstance(duration, float):
            for c in colors:
                if self.end_thread.is_set():
                    return
                self.set_color(c, internal=True)
                time.sleep(float(duration)/1000)
        elif isinstance(duration, list) and (len(colors) == len(duration)):
            for i, c in enumerate(colors):
                if self.end_thread.is_set():
                    return
                self.set_color(c, internal=True)
                time.sleep(float(duration[i])/1000)
        else:
            Exception("Dont know how to handle your color series")
            return
        self.flash_block.set()
        # If we received a color command while we were doing the series, set it now.
        # We call the function regardless, it will switch to a color if it has one
        self.set_color(stored=True)


class Solenoid(Hardware):
    """
    Solenoid valves for water delivery.

    Only NC solenoids should be used, as there is no way to guarantee
    that a pin will maintain its voltage when it is released, and you will
    spill water all over the place.

    Note:
        pigpio has a function to send waveforms, which would make solenoid
        opening far more accurate. If you are using an audio device, however,
        creating and sending waveforms disables it. Waveforms are thus not
        implemented here, but their implementation is left, skeleton-like,
        in the source should you do an experiment without audio that
        needs more precision.

        It's hard to see why submillisecond precision
        would matter all that much for reward delivery, but such is the
        obsessiveness of scientists.
    """

    output = True
    type = "PORTS"
    mode = "DURATION" # whether we dispense a fixed duration or fixed volume

    def __init__(self, pin, duration=20, vol=None):
        """
        Args:
            pin (int): Board pin number, converted to BCM on init.
            duration (int, float): duration of open, ms.
            vol (int, float): desired volume of reward in uL, must have computed calibration results, see :method:`~autopilot.core.terminal.Terminal.calibrate_ports`
        """

        # Initialize connection to pigpio daemon
        self.pig = pigpio.pi()
        if not self.pig.connected:
            Exception('No connection to pigpio daemon could be made')

        # Setup port
        self.pin = BOARD_TO_BCM[int(pin)]
        self.pig.set_mode(self.pin, pigpio.OUTPUT)

        # Pigpio has us create waves to deliver timed output
        # Since we typically only use one duration,
        # we make the wave once and only make it again when asked to
        # We start with passed or default duration (ms)
        if vol:
            self.dur_from_vol(vol)

        else:
            self.duration = float(duration)/1000
            #self.wave_id = None
            #self.make_wave()

    def dur_from_vol(self, vol):
        """
        Given a desired volume, set our open duration.

        Args:
            vol (float, int): desired reward volume in uL

        Returns:

        """
        # find our pin name
        self.name = self.get_name()
        # prefs should have loaded any calibration
        self.calibration = prefs.PORT_CALIBRATION[self.name]
        # compute duration from slope and intercept
        self.duration = (float(self.calibration['intercept']) + (float(self.calibration['slope']) * float(vol))) / 1000.0
        # some limits to this stuff
        if self.duration < .002:
            self.duration = 0.002


        print('USING OPEN TIME {} FOR PORT {}'.format(self.duration, self.name))
        sys.stdout.flush()

        self.mode = "VOLUME"

    def __del__(self):
        self.pig.stop()

    def release(self):
        """
        Simply releases the pigpio resources
        """
        self.pig.stop()
    #
    # def make_wave(self, duration=None):
    #     """
    #     Args:
    #         duration:
    #     """
    #
    #     # Typically duration is stored as an attribute, but if we are passed one...
    #     if duration:
    #         self.duration = int(duration)
    #
    #     # Make a pulse (duration is in microseconds for pigpio, ours is in milliseconds
    #     # Pulses are (pin to turn on, pin to turn off, delay)
    #     # So we add two pulses, one to turn the pin on with a delay,
    #     # then a second to turn the pin off with no delay.
    #     reward_pulse = []
    #     reward_pulse.append(pigpio.pulse(1<<self.pin, 0, self.duration*1000))
    #     reward_pulse.append(pigpio.pulse(0, 1<<self.pin, 0))
    #
    #     self.pig.wave_add_generic(reward_pulse)
    #     self.wave_id = self.pig.wave_create()

    def open(self, duration=None):
        """
        Open the valve.

        Args:
            duration (float): If provided, open for this duration instead of
                the duration stored on instantiation.
        """
        if duration:
            try:
                duration = float(duration)
            except:
                Warning('Need to pass a float for duration, using default dur')
                duration = self.duration
        else:
            duration = self.duration

        #self.pig.wave_send_once(self.wave_id)
        self.pig.write(self.pin, 1)
        time.sleep(duration)
        self.pig.write(self.pin, 0)


class Pull(Hardware):
    """
    Pull a pin up or down. Called by the :class:`~.pilot.Pilot` instead of by
    a :class:`~.task.Task` as is usual.

    If a pin should be pulled up or down always, regardless of task,
    use this. For example, the `otherwise wonderful HiFiBerry Amp 2 <https://www.hifiberry.com/shop/boards/hifiberry-amp2/>`_
    has an undocumented ... feature ... : the (board) pin 8 mutes output when low.
    """

    def __init__(self, pin, pud):
        """
        Args:
            pin (int): (Board) pin number
            pud ('U', 'D'): Pull the pin 'U'p or 'D'own.
        """
        self.pig = pigpio.pi()
        if not self.pig.connected:
            Exception('No connection to pigpio daemon could be made')

        self.pin = BOARD_TO_BCM[int(pin)]

        if pud == 1:
            self.pig.set_pull_up_down(self.pin, pigpio.PUD_UP)
        elif pud == 0:
            self.pig.set_pull_up_down(self.pin, pigpio.PUD_DOWN)



    def __del__(self):
        self.pig.stop()

    def release(self):
        """
        Simply releases the pigpio client.
        """
        self.pig.stop()

