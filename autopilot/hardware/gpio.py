"""
Hardware that uses the GPIO pins of the Raspi. These classes rely on `pigpio
<http://abyz.me.uk/rpi/pigpio/>`_, whose daemon (pigpiod) must be running in the background --
typically this is handled with a launch script/system daemon (see the launch_pilot.sh script generated by setup_pilot.py)

Note:
    This module does not include hardware that uses the GPIO pins over a specific protocol like i2c
"""
import sys
import threading
import time
import numpy as np
from datetime import datetime


from autopilot import prefs
from autopilot.hardware import Hardware, BOARD_TO_BCM, TRIGGER_MAP, PULL_MAP

ENABLED = False
try:
    import pigpio

    TRIGGER_MAP = {
        'U': pigpio.RISING_EDGE,
        1: pigpio.RISING_EDGE,
        True: pigpio.RISING_EDGE,
        'D': pigpio.FALLING_EDGE,
        0: pigpio.FALLING_EDGE,
        False: pigpio.FALLING_EDGE,
        'B': pigpio.EITHER_EDGE,
        (0,1): pigpio.EITHER_EDGE,
        [0,1]: pigpio.EITHER_EDGE
    }

    INVERSE_TRIGGER_MAP = {
        pigpio.RISING_EDGE: 'U',
        pigpio.FALLING_EDGE: 'D',
        pigpio.EITHER_EDGE: 'B'
    }
    """
    Inverse of TRIGGER_MAP. Used to assign canonical references to triggers -- 
    ie. it is possible to take multiple params -> pigpio objects, but one preferred
    way to refer to a pigpio object.
    """



    ENABLED = True
except ImportError:
    # TODO: log
    ImportWarning("pigpio could not be imported, gpio not enabled")


class GPIO(Hardware):
    """
    Metaclass for hardware that uses GPIO. Should not be instantiated on its own.

    Handles initializing pigpio and wraps some of its commonly used methods

    Args:
        pin (int): The Board-numbered GPIO pin of this object.
        trigger_edge: The pigpio object representing RISING_EDGE, FALLING_EDGE, BOTH_EDGES. Set by :attr`.trigger`

    Attributes:
        pig (:class:`pigpio.pi`): An object that manages connection to the pigpio daemon. See docs at http://abyz.me.uk/rpi/pigpio/python.html
        CONNECTED (bool): Whether the connection to pigpio was successful
        pin_bcm (int): The BCM number of the connected pin -- used by pigpio. Converted from pin passed as argument on initialization, which is assumed to be the board number.
        pull (str, int): state of pullup/down resistor. Can be set as 'U'/'D' or 1/0 to pull up/down
        polarity (int): Logic direction. if 1: on=High=1, off=Low=0; if 0: off=Low=0, on=High=1
        on (int): if polarity == 1, high/1. if polarity == 0, low/0
        off (int): if polarity == 1, low/0. if polarity == 0, high/1
        trigger (str, 1): which
    """

    def __init__(self, pin, polarity=1, pull = None, trigger = None):
        super(GPIO, self).__init__()

        # initialize attributes
        self._polarity = None
        self._pull = None
        self._pin = None
        self._trigger = None
        self.trigger_edge = None
        self.pin_bcm = None
        self.pig = None
        self.CONNECTED = False

        # set default attributes
        self.pin = pin
        self.polarity = polarity
        self.pull = pull
        self.trigger = trigger
        self.CONNECTED = self.init_pigpio()


    def init_pigpio(self):
        self.pig = pigpio.pi()
        if self.pig.connected:
            return True
        else:
            return False

    @property
    def pin(self):
        """
        Board-numbered GPIO pin.

        Only made a property so that if pin is changed pin_bcm is also changed
        """
        return self._pin

    @pin.setter
    def pin(self, pin):
        assert(int(pin))

        self._pin = int(pin)
        self.pin_bcm = BOARD_TO_BCM[self._pin]

    @property
    def pull(self):
        """
        State of pull

        Returns:
            int: 1/0/None for pulled up, down or not set.
        """
        return self._pull

    @pull.setter
    def pull(self, direction):

        if direction in (1, 'U', True):
            pull = pigpio.PUD_UP
            self._pull = 1
        elif direction in (0, 'D', False):
            pull = pigpio.PUD_DOWN
            self._pull = 0
        elif direction is None:
            pull = pigpio.PUD_OFF
            self._pull = None
        else:
            ValueError("pull must be one of 0/'D' for pulldown, 1/'U' for pullup, or None to clear")
            return

        self._pull = direction
        self.pig.set_pull_up_down(self.pin_bcm, pull)

    @property
    def polarity(self):
        """
        Logic direction. if 1: on=High=1, off=Low=0; if 0: off=Low=0, on=High=1.

        Only a property so on/off are set if changed
        """
        return self._polarity

    @polarity.setter
    def polarity(self, polarity):
        if polarity == 1:
            self.on = 1
            self.off = 0
        elif polarity == 0:
            self.on = 0
            self.off = 1
        else:
            ValueError('polarity must be 0 or 1')
            return

        self._polarity = polarity

    @property
    def trigger(self):
        """
        dict: Maps strings (('U',1,True), ('D',0,False), ('B',[0,1])) to pigpio edge types
        (RISING_EDGE, FALLING_EDGE, EITHER_EDGE), respectively.
        """
        return self._trigger


    @trigger.setter
    def trigger(self, trigger):
        # if trigger in ('U', 1, True):
        #     self._trigger = 'U'
        #     self.trigger_edge = pigpio.RISING_EDGE
        # elif trigger in ('D', 0, False):
        #     self._trigger = "D"
        #     self.trigger_edge = pigpio.FALLING_EDGE
        # elif trigger in ('B', [0,1], (0,1)):
        #     self._trigger = "D"
        #     self.trigger_edge = pigpio.EITHER_EDGE
        # else:
        #     ValueError('trigger must be one of U, D, B. instead got {}'.format(trigger))

        # TODO: test if this is equivalent to above (ie. does this work when key is (0,1)?)
        if trigger in TRIGGER_MAP.keys():
            self.trigger_edge = TRIGGER_MAP[trigger]
            self._trigger = INVERSE_TRIGGER_MAP[self.trigger_edge]
        else:
            ValueError('trigger must be one of {}. instead got {}'.format(INVERSE_TRIGGER_MAP.values(),
                                                                          trigger))

    def release(self):
        """
        Release the connection to the pigpio daemon.

        Note:
            the Hardware metaclass will call this method on object deletion.
        """
        self.pull = None
        self.pig.stop()


class Digital_Out(GPIO):
    """
    Send digital output pulses over a GPIO pin.

    """

    output = True
    type="DIGITAL_OUT"

    def __init__(self, pin, pulse_width=100, polarity=1):
        """
        Args:
            pin (int):
            pulse_width (int): Width of digital output pulse (us). range: 1-100
            polarity (bool): Whether 'on' is High (1, default) and pulses bring the voltage High, or vice versa (0)
        """
        super(Digital_Out, self).__init__(pin, polarity=polarity)


        self.pulse_width = np.clip(pulse_width, 0, 100).astype(np.int)
        if pulse_width > 100 or pulse_width < 0:
            Warning('pulse_width must be <100(ms) & >0 and has been clipped to {}'.format(self.pulse_width))

        # setup pin
        self.pig.set_mode(self.pin, pigpio.OUTPUT)
        self.pig.write(self.pin, self.off)

    def pulse(self, duration=None):

        if not duration:
            self.pig.gpio_trigger(self.pin_bcm, self.pulse_width, self.on)

        elif duration:
            duration = np.clip(duration, 0, 100).astype(np.int)
            self.pig.gpio_trigger(self.pin_bcm,
                                  duration,
                                  self.on)

    def release(self):
        self.pig.write(self.pin_bcm, self.off)
        self.pig.stop()


class Digital_In(GPIO):
    """
    Record digital input and call one or more callbacks on logic transition.

    Attributes:
        pig (:meth:`pigpio.pi`): The pigpio connection.
        pin (int): Broadcom-numbered pin, converted from the argument given on instantiation
        callbacks (list): A list of :meth:`pigpio.callback`s kept to clear them on exit
        polarity (int): Logic direction, if 1: off=0, on=1, pull=low, trigger=high and vice versa for 0
        events (list): if :attr:`.record` is True, a list of tuple

            Note:
                pull and trigger are set by polarity on initialization in digital inputs, unlike other GPIO classes.
                They are not mutually synchronized however, ie. after initialization if any one of these attributes are changed, the other two will remain the same.
    """
    is_trigger=True
    type = 'DIGI_IN'
    input = True

    def __init__(self, pin, polarity=1, event=None, record=True):
        """
        Args:
            pin (int): Board-numbered pin, converted to BCM numbering during instantiation.
            pull_ud ('U', 'D', 'B'): Should this beambreak be pulled up or down?
            trigger_ud ('U', 'D', 'B'): Is the trigger event up (low to high) or down (high to low)?
            event (:class:`threading.Event`): We can be passed an Event object if we want to handle
                stage transition logic here instead of the :class:`.Task` object, as is typical.
            record (bool): Whether logic transitions should be recorded as a list of ('EVENT', 'Timestamp') tuples.
        """
        super(Digital_In, self).__init__(pin, polarity=polarity)

        # pull the resistor in the off direction and set the trigger to be the on direction
        self.pull = self.off
        self.trigger = self.on

        # We can be passed a threading.Event object if we want to handle stage logic here
        # rather than in the parent as is typical.
        self.event = event

        # List to store callback handles assigned with assign_cb
        self.callbacks = []

        # List to store logic transition events
        self.events = []

        self.record = record
        if self.record:
            self.assign_cb(self.record_event, add=True, evented=False, manual_trigger='B')

        # Setup pin
        self.pig.set_mode(self.pin_bcm, pigpio.INPUT)

    def assign_cb(self, callback_fn, add=True, evented=False, manual_trigger=None):
        """
        Sets `callback_fn` to be called when triggered.

        Args:
            callback_fn (callable): The function to be called when triggered
            add (bool): Are we adding another callback?
                If False, the previous callbacks are cleared.
            evented (bool): Should triggering this event also set the internal :attr:`~.Beambreak.event`?
                Note that :attr:`.Beambreak.event` must have been passed.
            manual_trigger ('U', 'D', 'B'): We can override :attr:`.Beambreak.trigger_ud` if needed.
        """
        # If we aren't adding, we clear any existing callbacks
        if not add:
            self.clear_cb()

        # We can set the direction of the trigger manually,
        # for example if we want to set 'BOTH' only sometimes
        if not manual_trigger:
            trigger_ud = self.trigger_edge
        else:
            trigger_ud = TRIGGER_MAP[manual_trigger]

        # We can handle eventing (blocking) here if we want (usually this is handled in the parent)
        # This won't work if we weren't init'd with an event.
        if evented and self.event:
            cb = self.pig.callback(self.pin_bcm, trigger_ud, self.event.set)
            self.callbacks.append(cb)
        elif evented and not self.event:
            Exception('We have no internal event to set!')

        cb = self.pig.callback(self.pin_bcm, trigger_ud, callback_fn)
        self.callbacks.append(cb)

    def clear_cb(self):
        """
        Tries to call `.cancel()` on each of the callbacks in :attr:`Beambreak.callbacks`
        """
        for cb in self.callbacks:
            try:
                cb.cancel()
            except:
                pass
        self.callbacks = []

    def record_event(self, pin, level, tick):
        """
        On either direction of logic transition, record the time

        Todo:
            Currently both the pigpio tick and a datetime.now() timestamp are stored.
            When a method to convert ticks to timestamps is written and timestamps are unified,
            there shall be the one true timestamp.

        Args:
            pin (int): BCM numbered pin passed from pigpio
            level (bool): High/Low status of current pin
            tick (int): 32-bit integer, ticks since system start
        """

        # use self.pin rather than incoming pin b/c method is bound
        # (ie. only will be called by pin assigned to)
        # and self.pin is board rather than bcm numbered
        # TODO: translate ticks to timestamps already
        # FIXME: For now storing both timestamps and ticks which seems bad
        self.events.append((self.pin, level, tick, datetime.now().isoformat()))


    def release(self):
        self.clear_cb()
        super(Digital_In, self).release()

class PWM(GPIO):
    # TODO: Jonny start here, stopped 1/21/2020



class LED_RGB(Hardware):
    # TODO: Refactor to use three PWM objects
    """
    An RGB LED.

    Attributes:
        pig (:meth:`pigpio.pi`): The pigpio connection.
        flash_block (:class:`threading.Event`): An Event to wait on setting further colors
            if we are currently in a threaded flash train
        end_thread (:class:`threading.Event`): Set this event to stop a flash train - usually called during object cleanup
        pins (dict): After init, pin numbers are kept in a dict like::

            {'r':bcm_number, 'g':...}

        stored_color (dict): A color we store to restore after we do a flash train.

    """

    output = True
    type="LEDS"

    def __init__(self, pins = None, r = None, g=None, b=None, common = 'anode', blink=True):
        """
        Args:
            pins (list): A list of (board) pin numbers.
                Either `pins` OR all `r`, `g`, `b` must be passed.
            r (int): Board number of Red pin - must be passed with `g` and `b`
            g (int): Board number of Green pin - must be passed with `r` and `b`
            b (int): Board number of Blue pin - must be passed with `r` and `g`:
            common ('anode', 'cathode'): Is this LED common anode (low turns LED on)
                or cathode (low turns LED off)
            blink (bool): Flash RGB at the end of init to show we're alive.
        """
        self.common = common

        # Dict to store color for after flash trains
        self.stored_color = {}

        # Event to wait on setting colors if we're flashing
        self.flash_block = threading.Event()
        self.flash_block.set()

        # Event to kill the flash thread if the object is deleted
        self.end_thread = threading.Event()
        self.end_thread.clear()

        # Initialize connection to pigpio daemon
        self.pig = pigpio.pi()
        if not self.pig.connected:
            Exception('No connection to pigpio daemon could be made')

        # Unpack input
        self.pins = {}
        if r and g and b:
            self.pins['r'] = int(r)
            self.pins['g'] = int(g)
            self.pins['b'] = int(b)
        elif isinstance(pins, list):
            self.pins['r'] = int(pins[0])
            self.pins['g'] = int(pins[1])
            self.pins['b'] = int(pins[2])
        else:
            Exception('Dont know how to handle input to LED_RGB')

        # Convert to BCM numbers
        self.pins = {k: BOARD_TO_BCM[v] for k, v in self.pins.items()}

        # set pin mode to output and make sure they're turned off
        for pin in self.pins.values():
            self.pig.set_mode(pin, pigpio.OUTPUT)
            if self.common == 'anode':
                self.pig.set_PWM_dutycycle(pin, 255)
            elif self.common == 'cathode':
                self.pig.set_PWM_dutycycle(pin, 0)
            else:
                Exception('Common passed to LED_RGB not anode or cathode')

        # Blink to show we're alive
        if blink:
            self.color_series([[255,0,0],[0,255,0],[0,0,255],[0,0,0]], 250)

    def __del__(self):
        self.release()


    def release(self):
        """
        Turns LED off and releases pigpio.
        """
        self.end_thread.set()
        self.set_color(col=[0,0,0])
        self.pig.stop()

    def set_color(self, col=None, r=None, g=None, b=None, timed=None, stored=False, internal=False):
        """
        Set the color of the LED.

        Note:
            if called during a :meth:`LED_RGB.color_series`, the color will be stashed and set when the train is over.

        Args:
            col (list, tuple): an RGB color trio ranging from 0-255. Either `col` or all of `r`, `g`, `b` must be provided
            r (int): Red intensity 0-255. Must be passed with `g` and `b`
            g (int): Green intensity 0-255. Must be passed with `r` and `b`
            b (int): Blue intensity 0-255. Must be passed with `r` and `g`
            timed (float): Duration to change to this color before turning off in ms.
            stored (bool): Called internally to change back to the color that preceded a flash train. Restores :attr:`LED_RGB.stored_color`.
            internal (bool): True if being called inside a flash train.
        """
        if stored:
            # being called after a flash train
            # Since this is always called after a flash train, check that we were actually assigned a color
            if self.stored_color:
                color = self.stored_color
                self.stored_color = {}
            else:
                # It's fine not to have a color, just return quietly.
                return
        else:
            # Unpack input
            if r and g and b:
                color = {'r':int(r), 'g':int(g), 'b':int(b)}
            elif isinstance(col, list) or isinstance(col, tuple):
                color = {'r':int(col[0]), 'g':int(col[1]), 'b':int(col[2])}
            else:
                Warning('Color improperly formatted')
                return

        # If we're flashing or doing a color series, stash the color and we'll set it after the flash is done
        # the 'internal' flag checks if this is being called within a flash train
        if not internal and not self.flash_block.is_set():
            self.stored_color = color
            return

        # Set PWM dutycycle
        try:
            if self.common == 'anode':
                for k, v in color.items():
                    self.pig.set_PWM_dutycycle(self.pins[k], 255-v)
            elif self.common == 'cathode':
                for k, v in color.items():
                    self.pig.set_PWM_dutycycle(self.pins[k], v)
        except AttributeError:
            # if object has been cleaned up and a lingering set_color command remains,
            # pigpio will throw an attribute error because its interface has been deleted
            # we can return peacefully
            # TODO: Log this
            return

        # If this is is a timed blink, start thread to turn led off
        if timed:
            # timed should be a float or int specifying the delay in ms
            offtimer = threading.Timer(float(timed)/1000, self.set_color, kwargs={'col':[0,0,0]})
            offtimer.start()

    def flash(self, duration, frequency=10, colors=[[255,255,255],[0,0,0]]):
        """
        Specify a color series by total duration and flash frequency.

        Largely a convenience function for on/off flashes.

        Args:
            duration (int, float): Duration of flash in ms.
            frequency (int, float): Frequency of flashes in Hz
            colors (list): A list of RGB values 0-255 like::

                [[255,255,255],[0,0,0]]

        """
        # Duration is total in ms, frequency in Hz
        # Get number of flashes in duration rounded down

        n_rep = int(float(duration)/1000.*float(frequency))
        flashes = colors*n_rep

        # Invert frequency to duration for single flash
        # divide by 2 b/c each 'color' is half the duration
        single_dur = ((1./frequency)*1000)/2.
        self.color_series(flashes, single_dur)

    def color_series(self, colors, duration):
        """
        Change color through a series for a fixed duration.

        Wrapper around :meth:`LED_RGB.threaded_color_series`

        Args:
            colors (list): A list of RGB values 0-255 like::

                [[255,255,255],[0,0,0]]

            duration (int, list): Either a single duration (int, ms)
                or list of ints of equal length to `colors` to define
                duration for each.
        """
        # Just a wrapper to make threaded
        series_thread = threading.Thread(target=self.threaded_color_series, kwargs={'colors':colors, 'duration':duration})
        series_thread.start()

    def threaded_color_series(self, colors, duration):
        """
        Should only be called by :meth:`.LED_RGB.color_series` because it blocks.

        Clears :attr:`.LED_RGB.flash_block` , sets colors, sleeps, sets the block, and
        then sets any color that was passed during the train.

        Args:
            colors (list): A list of RGB values 0-255 like::

                [[255,255,255],[0,0,0]]

            duration (int, list): Either a single duration (int, ms)
                or list of ints of equal length to `colors` to define
                duration for each.
        """
        self.flash_block.clear()
        if isinstance(duration, int) or isinstance(duration, float):
            for c in colors:
                if self.end_thread.is_set():
                    return
                self.set_color(c, internal=True)
                time.sleep(float(duration)/1000)
        elif isinstance(duration, list) and (len(colors) == len(duration)):
            for i, c in enumerate(colors):
                if self.end_thread.is_set():
                    return
                self.set_color(c, internal=True)
                time.sleep(float(duration[i])/1000)
        else:
            Exception("Dont know how to handle your color series")
            return
        self.flash_block.set()
        # If we received a color command while we were doing the series, set it now.
        # We call the function regardless, it will switch to a color if it has one
        self.set_color(stored=True)


class Solenoid(Hardware):
    """
    Solenoid valves for water delivery.

    Only NC solenoids should be used, as there is no way to guarantee
    that a pin will maintain its voltage when it is released, and you will
    spill water all over the place.

    Note:
        pigpio has a function to send waveforms, which would make solenoid
        opening far more accurate. If you are using an audio device, however,
        creating and sending waveforms disables it. Waveforms are thus not
        implemented here, but their implementation is left, skeleton-like,
        in the source should you do an experiment without audio that
        needs more precision.

        It's hard to see why submillisecond precision
        would matter all that much for reward delivery, but such is the
        obsessiveness of scientists.
    """

    output = True
    type = "PORTS"
    mode = "DURATION" # whether we dispense a fixed duration or fixed volume

    def __init__(self, pin, duration=20, vol=None):
        """
        Args:
            pin (int): Board pin number, converted to BCM on init.
            duration (int, float): duration of open, ms.
            vol (int, float): desired volume of reward in uL, must have computed calibration results, see :method:`~autopilot.core.terminal.Terminal.calibrate_ports`
        """

        # Initialize connection to pigpio daemon
        self.pig = pigpio.pi()
        if not self.pig.connected:
            Exception('No connection to pigpio daemon could be made')

        # Setup port
        self.pin = BOARD_TO_BCM[int(pin)]
        self.pig.set_mode(self.pin, pigpio.OUTPUT)

        # Pigpio has us create waves to deliver timed output
        # Since we typically only use one duration,
        # we make the wave once and only make it again when asked to
        # We start with passed or default duration (ms)
        if vol:
            self.dur_from_vol(vol)

        else:
            self.duration = float(duration)/1000
            #self.wave_id = None
            #self.make_wave()

    def dur_from_vol(self, vol):
        """
        Given a desired volume, set our open duration.

        Args:
            vol (float, int): desired reward volume in uL

        Returns:

        """
        # find our pin name
        self.name = self.get_name()
        # prefs should have loaded any calibration
        self.calibration = prefs.PORT_CALIBRATION[self.name]
        # compute duration from slope and intercept
        self.duration = (float(self.calibration['intercept']) + (float(self.calibration['slope']) * float(vol))) / 1000.0
        # some limits to this stuff
        if self.duration < .002:
            self.duration = 0.002


        print('USING OPEN TIME {} FOR PORT {}'.format(self.duration, self.name))
        sys.stdout.flush()

        self.mode = "VOLUME"

    def __del__(self):
        self.pig.stop()

    def release(self):
        """
        Simply releases the pigpio resources
        """
        self.pig.stop()
    #
    # def make_wave(self, duration=None):
    #     """
    #     Args:
    #         duration:
    #     """
    #
    #     # Typically duration is stored as an attribute, but if we are passed one...
    #     if duration:
    #         self.duration = int(duration)
    #
    #     # Make a pulse (duration is in microseconds for pigpio, ours is in milliseconds
    #     # Pulses are (pin to turn on, pin to turn off, delay)
    #     # So we add two pulses, one to turn the pin on with a delay,
    #     # then a second to turn the pin off with no delay.
    #     reward_pulse = []
    #     reward_pulse.append(pigpio.pulse(1<<self.pin, 0, self.duration*1000))
    #     reward_pulse.append(pigpio.pulse(0, 1<<self.pin, 0))
    #
    #     self.pig.wave_add_generic(reward_pulse)
    #     self.wave_id = self.pig.wave_create()

    def open(self, duration=None):
        """
        Open the valve.

        Args:
            duration (float): If provided, open for this duration instead of
                the duration stored on instantiation.
        """
        if duration:
            try:
                duration = float(duration)
            except:
                Warning('Need to pass a float for duration, using default dur')
                duration = self.duration
        else:
            duration = self.duration

        #self.pig.wave_send_once(self.wave_id)
        self.pig.write(self.pin_bcm, 1)
        time.sleep(duration)
        self.pig.write(self.pin_bcm, 0)


class Pull(Hardware):
    """
    Pull a pin up or down. Called by the :class:`~.pilot.Pilot` instead of by
    a :class:`~.task.Task` as is usual.

    If a pin should be pulled up or down always, regardless of task,
    use this. For example, the `otherwise wonderful HiFiBerry Amp 2 <https://www.hifiberry.com/shop/boards/hifiberry-amp2/>`_
    has an undocumented ... feature ... : the (board) pin 8 mutes output when low.
    """

    def __init__(self, pin, pud):
        """
        Args:
            pin (int): (Board) pin number
            pud ('U', 'D'): Pull the pin 'U'p or 'D'own.
        """
        self.pig = pigpio.pi()
        if not self.pig.connected:
            Exception('No connection to pigpio daemon could be made')

        self.pin = BOARD_TO_BCM[int(pin)]

        if pud in ('U', 1):
            self.pig.set_pull_up_down(self.pin, pigpio.PUD_UP)
        elif pud in ('D', 0):
            self.pig.set_pull_up_down(self.pin, pigpio.PUD_DOWN)
        else:
            raise Exception("Don't know what to do with this pull!")


    def __del__(self):
        self.pig.stop()

    def release(self):
        """
        Simply releases the pigpio client.
        """
        self.pig.stop()













